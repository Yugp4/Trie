if(root.firstChild != null) {
			int sIndex = 0;
			int eIndex = -1;
			int len = s.length();
			if(start != (short)(0) || end != (short)(s.length()-1)) {
				sIndex = start;
				len = end;
			}
			String ptrString = allWords[root.substr.wordIndex].substring(root.substr.startIndex, (root.substr.endIndex)+1);
			if(ptrString.length() < s.length()) {
				len = ptrString.length();
			}	
				for(int c = sIndex; c < len; c++) {
					if(s.charAt(c-start) != ptrString.charAt(c-start)) {
						break;
					}
					eIndex = c;
				}
			if(eIndex == -1) {
				if(root.sibling != null) {
					recurseBuild(s, ind, (short)(start), (short)(end), allWords, root.sibling);
					return;
				}else {
					root.sibling = new TrieNode(new Indexes(ind, (short)(start), (short)(end)), null, null);
					return;
				}
			}else {
				if(root.firstChild != null) {
					if(eIndex - sIndex < root.substr.endIndex) {
						TrieNode pre = new TrieNode(new Indexes(root.substr.wordIndex, (short)(sIndex), (short)(eIndex)), null, null);
						pre.firstChild = new TrieNode(new Indexes(root.substr.wordIndex, (short)(root.substr.startIndex+(pre.substr.endIndex+1)), root.substr.endIndex), root.firstChild, null);
						root.substr = pre.substr;
						root.firstChild = pre.firstChild;
						pre.sibling = root.sibling;
						root.sibling = pre.sibling;
						recurseBuild(s.substring(eIndex+1), ind, (short)(eIndex+1), (short)(end), allWords, root.firstChild);
						return;
					}else {
					recurseBuild(s.substring(eIndex +1), ind, (short)(eIndex+1), (short)(end), allWords, root.firstChild);
					return;
					}
				}else {
					TrieNode common = new TrieNode(null, null, null);
					common.substr = new Indexes(root.substr.wordIndex, (short)(sIndex), (short)(eIndex));
					common.firstChild = new TrieNode(new Indexes(root.substr.wordIndex, (short)(eIndex+1), (short)(root.substr.endIndex)),null, null);
					common.firstChild.sibling = new TrieNode(new Indexes(ind, (short)(eIndex+1), (short)(end)), null, null);
					root.substr = common.substr;
					root.firstChild = common.firstChild;
					root.sibling = common.sibling;
					return;
				}
			}
		}else {
			int sIndex = start;
			int eIndex = -1;
			int len = end;
			String rootString = allWords[root.substr.wordIndex].substring(root.substr.startIndex, root.substr.endIndex+1);
			if(rootString.length() < s.length()) {
				len = rootString.length();
			}
			for(int c = sIndex; c < len; c++) {
				if(s.charAt(c-start) != rootString.charAt(c-start)) {
					break;
				}
				eIndex = c;
			}
			if(eIndex == -1) {
				if(root.sibling != null) {
					recurseBuild(s, ind, start, end, allWords, root.sibling);
					return;
				}else {
					root.sibling = new TrieNode(new Indexes(ind, (short)(start), (short)(end)), null, null);
					return;
				}
            }else {
            	if(root.firstChild != null) {
					if(eIndex - sIndex < root.substr.endIndex) {
						TrieNode pre = new TrieNode(new Indexes(root.substr.wordIndex, (short)(sIndex), (short)(eIndex)), null, null);
						pre.firstChild = new TrieNode(new Indexes(root.substr.wordIndex, (short)(root.substr.startIndex+(pre.substr.endIndex+1)), root.substr.endIndex), root.firstChild, null);
						//root.substr = new Indexes(pre.substr.wordIndex, pre.substr.startIndex, pre.substr.endIndex);
						root.substr = pre.substr;
						//root.firstChild = new TrieNode(pre.firstChild.substr, pre.firstChild.firstChild, pre.firstChild.sibling);
						root.firstChild = pre.firstChild;
						pre.sibling = root.sibling;
						//root.sibling = new TrieNode(pre.sibling.substr, pre.sibling.firstChild, pre.sibling.sibling);
						root.sibling = pre.sibling;
						recurseBuild(s.substring(eIndex+1), ind, (short)(eIndex+1), (short)(end), allWords, root.firstChild);
						return;
					}else {
					recurseBuild(s.substring(eIndex +1), ind, (short)(eIndex+1), (short)(end), allWords, root.firstChild);
					return;
					}
				}
			   else {
				TrieNode common = new TrieNode(null, null, null);
				common.substr = new Indexes(root.substr.wordIndex, (short)(sIndex), (short)(eIndex));
				common.firstChild = new TrieNode(new Indexes(root.substr.wordIndex, (short)(eIndex+1), (short)(root.substr.endIndex)), null, null);
				common.sibling = root.sibling;
				common.firstChild.sibling = new TrieNode(new Indexes(ind, (short)(eIndex+1), (short)(end)), null, null);
				common.sibling = root.sibling;
				//root.substr = new Indexes(common.substr.wordIndex, common.substr.startIndex, common.substr.endIndex);
				root.substr = common.substr;
				//root.firstChild = new TrieNode(common.firstChild.substr, common.firstChild.firstChild, common.firstChild.sibling);
				root.firstChild = common.firstChild;
				//root.sibling = new TrieNode(common.sibling.substr, common.sibling.firstChild, common.sibling.sibling);
				root.sibling = common.sibling;
				return;
			}
		}
		}